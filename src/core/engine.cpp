#include "engine.hpp"
#include "cache.hpp"
#include "graph.hpp"
#include "../util/fs.hpp"
#include "../util/hash.hpp"
#include "../ui/terminal.hpp"

#include <fstream>
#include <sstream>
#include <filesystem>
#include <algorithm>
#include <cstdlib>
#include <thread>
#include <chrono>
#include <stdexcept>
#include <regex>

namespace fs = std::filesystem;

namespace iris::core {

Engine::Engine() = default;

Engine::Engine(const BuildConfig& config) : m_config(config) {}

void Engine::set_config(const BuildConfig& config) {
    m_config = config;
}

void Engine::load_from_build_dir(const std::string& build_dir) {
    m_build_dir = build_dir;
    
    std::string config_file = build_dir + "/iris-config.json";
    if (!fs::exists(config_file)) {
        throw std::runtime_error("No configuration found in " + build_dir);
    }
    
    // parse the config file
    std::ifstream file(config_file);
    if (!file.is_open()) {
        throw std::runtime_error("Cannot open " + config_file);
    }
    
    std::string line;
    while (std::getline(file, line)) {
        // simple json parsing extract key fields
        size_t pos;
        
        if ((pos = line.find("\"project\":")) != std::string::npos) {
            size_t start = line.find("\"", pos + 10) + 1;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                m_config.project_name = line.substr(start, end - start);
            }
        }
        
        if ((pos = line.find("\"version\":")) != std::string::npos) {
            size_t start = line.find("\"", pos + 10) + 1;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                m_config.version = line.substr(start, end - start);
            }
        }
        
        if ((pos = line.find("\"build_type\":")) != std::string::npos) {
            size_t start = line.find("\"", pos + 13) + 1;
            size_t end = line.find("\"", start);
            if (start != std::string::npos && end != std::string::npos) {
                m_config.build_type = line.substr(start, end - start);
            }
        }
    }
}

void Engine::generate_build_files(const std::string& build_dir,
                                   const std::string& backend) {
    m_build_dir = build_dir;
    fs::create_directories(build_dir);

    if (backend == "ninja") {
        generate_ninja(build_dir);
    } else if (backend == "make") {
        generate_makefile(build_dir);
    } else {
        throw std::runtime_error("Unknown backend: " + backend);
    }

    // save configuration as json
    std::ofstream config_out(build_dir + "/iris-config.json");
    config_out << "{\n";
    config_out << "  \"project\": \"" << m_config.project_name << "\",\n";
    config_out << "  \"version\": \"" << m_config.version << "\",\n";
    config_out << "  \"language\": \"" << m_config.language << "\",\n";
    config_out << "  \"standard\": \"" << m_config.standard << "\",\n";
    config_out << "  \"build_type\": \"" << m_config.build_type << "\",\n";
    config_out << "  \"backend\": \"" << backend << "\",\n";
    config_out << "  \"targets\": [\n";
    
    for (size_t i = 0; i < m_config.targets.size(); i++) {
        const auto& target = m_config.targets[i];
        config_out << "    {\n";
        config_out << "      \"name\": \"" << target.name << "\",\n";
        config_out << "      \"type\": \"";
        switch (target.type) {
            case TargetType::Executable: config_out << "executable"; break;
            case TargetType::Library: config_out << "library"; break;
            case TargetType::StaticLibrary: config_out << "static_library"; break;
            case TargetType::SharedLibrary: config_out << "shared_library"; break;
            default: config_out << "unknown"; break;
        }
        config_out << "\"\n";
        config_out << "    }";
        if (i < m_config.targets.size() - 1) {
            config_out << ",";
        }
        config_out << "\n";
    }
    
    config_out << "  ]\n";
    config_out << "}\n";
    config_out.close();
}

void Engine::generate_ninja(const std::string& build_dir) {
    using namespace ui;
    
    std::ofstream ninja(build_dir + "/build.ninja");
    if (!ninja.is_open()) {
        throw std::runtime_error("Cannot create build.ninja");
    }

    ninja << "# Generated by Iris Build System\n";
    ninja << "# Project: " << m_config.project_name << "\n";
    ninja << "# Do not edit manually\n\n";

    ninja << "ninja_required_version = 1.5\n\n";

    // compiler variables
    std::string cc = get_compiler();
    std::string cxx = get_cxx_compiler();
    
    ninja << "cc = " << cc << "\n";
    ninja << "cxx = " << cxx << "\n";
    ninja << "ar = ar\n\n";

    // compile rules
    if (m_config.language == "c" || m_config.language == "mixed") {
        ninja << "rule cc\n";
        ninja << "  command = $cc -MMD -MF $out.d $cflags -c $in -o $out\n";
        ninja << "  depfile = $out.d\n";
        ninja << "  deps = gcc\n";
        ninja << "  description = CC $out\n\n";
    }

    if (m_config.language == "cpp" || m_config.language == "mixed" || m_config.language.empty()) {
        ninja << "rule cxx\n";
        ninja << "  command = $cxx -MMD -MF $out.d $cxxflags -c $in -o $out\n";
        ninja << "  depfile = $out.d\n";
        ninja << "  deps = gcc\n";
        ninja << "  description = CXX $out\n\n";
    }

    // link rules
    ninja << "rule link_exe\n";
    ninja << "  command = $cxx $ldflags $in -o $out $libs\n";
    ninja << "  description = LINK $out\n\n";

    ninja << "rule link_shared\n";
    ninja << "  command = $cxx -shared $ldflags $in -o $out $libs\n";
    ninja << "  description = LINK_SHARED $out\n\n";

    ninja << "rule ar_static\n";
    ninja << "  command = $ar rcs $out $in\n";
    ninja << "  description = AR $out\n\n";

    // build statements for each target
    std::vector<std::string> all_outputs;

    for (const auto& target : m_config.targets) {
        std::vector<std::string> objects;
        std::string compile_flags = get_compile_flags(target);
        std::string link_flags = get_link_flags(target);
        std::string libs = get_libs(target);

        // resolve source files
        auto sources = resolve_sources(target);
        
        if (sources.empty()) {
            Terminal::warning("Target '" + target.name + "' has no sources");
            continue;
        }

        ninja << "# Target: " << target.name << "\n";

        // compile each source file
        for (const auto& src : sources) {
            fs::path src_path(src);
            std::string obj_name = src_path.stem().string();
            
            // handle duplicate filenames from different directories
            std::string rel_path = src;
            std::replace(rel_path.begin(), rel_path.end(), '/', '_');
            std::replace(rel_path.begin(), rel_path.end(), '\\', '_');
            if (rel_path.length() > 50) {
                // Use hash for very long paths
                obj_name = obj_name + "_" + util::hash::xxhash(src).substr(0, 8);
            } else {
                obj_name = fs::path(rel_path).stem().string();
            }
            
            std::string obj = "obj/" + target.name + "/" + obj_name + ".o";
            objects.push_back(obj);

            std::string ext = src_path.extension().string();
            bool is_c = (ext == ".c");
            std::string rule = is_c ? "cc" : "cxx";
            std::string flags_var = is_c ? "cflags" : "cxxflags";

            // determine source path relative to build dir
            std::string src_rel = "../" + src;
            
            ninja << "build " << obj << ": " << rule << " " << src_rel << "\n";
            ninja << "  " << flags_var << " = " << compile_flags << "\n";
        }

        ninja << "\n";

        // link or archive
        std::string output;
        
        switch (target.type) {
            case TargetType::Executable:
                output = target.name;
#ifdef _WIN32
                output += ".exe";
#endif
                ninja << "build " << output << ": link_exe";
                for (const auto& obj : objects) {
                    ninja << " " << obj;
                }
                ninja << "\n";
                ninja << "  ldflags = " << link_flags << "\n";
                if (!libs.empty()) {
                    ninja << "  libs = " << libs << "\n";
                }
                break;
                
            case TargetType::Library:
            case TargetType::StaticLibrary:
                output = "lib" + target.name + ".a";
                ninja << "build " << output << ": ar_static";
                for (const auto& obj : objects) {
                    ninja << " " << obj;
                }
                ninja << "\n";
                break;
                
            case TargetType::SharedLibrary:
                output = "lib" + target.name;
#ifdef __APPLE__
                output += ".dylib";
#elif defined(_WIN32)
                output += ".dll";
#else
                output += ".so";
#endif
                ninja << "build " << output << ": link_shared";
                for (const auto& obj : objects) {
                    ninja << " " << obj;
                }
                ninja << "\n";
                ninja << "  ldflags = " << link_flags << "\n";
                if (!libs.empty()) {
                    ninja << "  libs = " << libs << "\n";
                }
                break;
                
            default:
                continue;
        }

        ninja << "\n";
        all_outputs.push_back(output);
    }

    // default target
    ninja << "# Default target\n";
    ninja << "build all: phony";
    for (const auto& out : all_outputs) {
        ninja << " " << out;
    }
    ninja << "\n\n";

    ninja << "default all\n";

    ninja.close();

    // create object directories
    for (const auto& target : m_config.targets) {
        fs::create_directories(build_dir + "/obj/" + target.name);
    }

    Terminal::info("Generated", "build.ninja");
}

void Engine::generate_makefile(const std::string& build_dir) {
    using namespace ui;
    
    std::ofstream make(build_dir + "/Makefile");
    if (!make.is_open()) {
        throw std::runtime_error("Cannot create Makefile");
    }

    make << "# Generated by Iris Build System\n";
    make << "# Project: " << m_config.project_name << "\n";
    make << "# Do not edit manually\n\n";

    make << ".PHONY: all clean\n\n";

    // compiler variables
    std::string cc = get_compiler();
    std::string cxx = get_cxx_compiler();
    
    make << "CC := " << cc << "\n";
    make << "CXX := " << cxx << "\n";
    make << "AR := ar\n\n";

    std::vector<std::string> all_outputs;

    for (const auto& target : m_config.targets) {
        std::string compile_flags = get_compile_flags(target);
        std::string link_flags = get_link_flags(target);
        std::string libs = get_libs(target);
        auto sources = resolve_sources(target);

        if (sources.empty()) {
            continue;
        }

        std::vector<std::string> objects;
        
        for (const auto& src : sources) {
            fs::path src_path(src);
            std::string obj_name = src_path.stem().string();
            std::string obj = "obj/" + target.name + "/" + obj_name + ".o";
            objects.push_back(obj);
        }

        // determine output name
        std::string output;
        switch (target.type) {
            case TargetType::Executable:
                output = target.name;
                break;
            case TargetType::Library:
            case TargetType::StaticLibrary:
                output = "lib" + target.name + ".a";
                break;
            case TargetType::SharedLibrary:
#ifdef __APPLE__
                output = "lib" + target.name + ".dylib";
#else
                output = "lib" + target.name + ".so";
#endif
                break;
            default:
                continue;
        }
        
        all_outputs.push_back(output);

        make << "# Target: " << target.name << "\n";
        
        // target rule
        make << output << ":";
        for (const auto& obj : objects) {
            make << " " << obj;
        }
        make << "\n";

        switch (target.type) {
            case TargetType::Executable:
                make << "\t@echo \"  LINK    $@\"\n";
                make << "\t@$(CXX) " << link_flags << " $^ -o $@ " << libs << "\n";
                break;
            case TargetType::Library:
            case TargetType::StaticLibrary:
                make << "\t@echo \"  AR      $@\"\n";
                make << "\t@$(AR) rcs $@ $^\n";
                break;
            case TargetType::SharedLibrary:
                make << "\t@echo \"  LINK    $@\"\n";
                make << "\t@$(CXX) -shared " << link_flags << " $^ -o $@ " << libs << "\n";
                break;
            default:
                break;
        }
        make << "\n";

        // object rules
        for (size_t i = 0; i < sources.size(); i++) {
            fs::path src_path(sources[i]);
            std::string ext = src_path.extension().string();
            bool is_c = (ext == ".c");
            std::string compiler = is_c ? "$(CC)" : "$(CXX)";

            make << objects[i] << ": ../" << sources[i] << "\n";
            make << "\t@mkdir -p $(dir $@)\n";
            make << "\t@echo \"  " << (is_c ? "CC" : "CXX") << "     $<\"\n";
            make << "\t@" << compiler << " " << compile_flags << " -c $< -o $@\n";
            make << "\n";
        }
    }

    // all target
    make << "all:";
    for (const auto& out : all_outputs) {
        make << " " << out;
    }
    make << "\n\n";

    // clean target
    make << "clean:\n";
    make << "\t@echo \"  CLEAN\"\n";
    make << "\t@rm -rf obj/";
    for (const auto& out : all_outputs) {
        make << " " << out;
    }
    make << "\n";

    make.close();

    // create object directories
    for (const auto& target : m_config.targets) {
        fs::create_directories(build_dir + "/obj/" + target.name);
    }

    Terminal::info("Generated", "Makefile");
}

int Engine::build(const std::string& target,
                  int jobs,
                  bool verbose,
                  ProgressCallback progress) {
    (void)progress;
    
    if (m_build_dir.empty()) {
        m_build_dir = "build";
    }
    
    if (jobs == 0) {
        jobs = static_cast<int>(std::thread::hardware_concurrency());
        if (jobs == 0) jobs = 4;
    }

    bool has_ninja = fs::exists(m_build_dir + "/build.ninja");
    bool has_make = fs::exists(m_build_dir + "/Makefile");
    
    if (!has_ninja && !has_make) {
        throw std::runtime_error("No build files found in " + m_build_dir);
    }

    std::string cmd;
    
    if (has_ninja) {
        cmd = "ninja -C " + m_build_dir + " -j" + std::to_string(jobs);
        if (!target.empty()) {
            cmd += " " + target;
        }
    } else {
        cmd = "make -C " + m_build_dir + " -j" + std::to_string(jobs);
        if (!target.empty()) {
            cmd += " " + target;
        }
        cmd += " --no-print-directory";
    }
    
    // capture output and parse it
    cmd += " 2>&1";
    
    FILE* pipe = popen(cmd.c_str(), "r");
    if (!pipe) {
        throw std::runtime_error("Failed to run build command");
    }
    
    std::regex ninja_re(R"(\[(\d+)/(\d+)\]\s+(\S+)\s+(.+))");
    std::string error_output;
    int total = 0;
    int current = 0;
    int failed = 0;
    bool in_error = false;
    
    char buffer[512];
    while (fgets(buffer, sizeof(buffer), pipe) != nullptr) {
        std::string line(buffer);
        
        // remove trailing newline
        if (!line.empty() && line.back() == '\n') {
            line.pop_back();
        }
        
        // skip empty lines
        if (line.empty()) continue;
        
        // skip "Entering directory" messages
        if (line.find("Entering directory") != std::string::npos) continue;
        if (line.find("Leaving directory") != std::string::npos) continue;
        
        // parse ninja progress blah blah
        std::smatch match;
        if (std::regex_search(line, match, ninja_re)) {
            current = std::stoi(match[1].str());
            total = std::stoi(match[2].str());
            std::string action = match[3].str();
            std::string file = match[4].str();
            
            // clear line and show progress
            std::cout << "\r\033[K";
            
            ui::Terminal::print_styled("  [", ui::Color::Gray);
            std::cout << current << "/" << total;
            ui::Terminal::print_styled("] ", ui::Color::Gray);
            
            if (action == "CXX" || action == "CC") {
                ui::Terminal::print_styled(action == "CXX" ? "CXX " : "CC  ", ui::Color::Cyan);
            } else if (action == "LINK") {
                ui::Terminal::print_styled("LINK", ui::Color::Magenta);
            } else if (action == "AR") {
                ui::Terminal::print_styled("AR  ", ui::Color::Yellow);
            } else {
                ui::Terminal::print_styled(action + " ", ui::Color::White);
            }
            
            // shorten path
            std::string display = file;
            if (display.length() > 50) {
                size_t slash = display.rfind('/');
                if (slash != std::string::npos) {
                    display = "..." + display.substr(slash);
                }
            }
            std::cout << display << std::flush;
            
            in_error = false;
        }
        else if (line.find("FAILED") != std::string::npos) {
            std::cout << "\r\033[K";
            ui::Terminal::print_styled("  FAIL ", ui::Color::Red, ui::Style::Bold);
            std::cout << "\n";
            failed++;
            in_error = true;
        }
        else if (line.find("error:") != std::string::npos || in_error) {
            // show compiler errors
            if (verbose || in_error) {
                if (line.find("error:") != std::string::npos) {
                    std::cout << "       " << line << "\n";
                }
            }
            error_output += line + "\n";
        }
        else if (line.find("warning:") != std::string::npos && verbose) {
            // show warnings in verbose mode
            std::cout << "\r\033[K";
            ui::Terminal::print_styled("  WARN ", ui::Color::Yellow);
            std::cout << line << "\n";
        }
    }
    
    int status = pclose(pipe);
    int result = WIFEXITED(status) ? WEXITSTATUS(status) : -1;
    
    // clear progress line
    std::cout << "\r\033[K";
    
    return result;
}
std::vector<std::string> Engine::resolve_sources(const Target& target) const {
    std::vector<std::string> result;

    for (const auto& pattern : target.sources) {
        if (pattern.find('*') != std::string::npos) {
            // glob pattern
            auto files = expand_glob(pattern);
            result.insert(result.end(), files.begin(), files.end());
        } else {
            // direct file path
            if (fs::exists(pattern)) {
                result.push_back(pattern);
            } else {
                ui::Terminal::warning("Source file not found: " + pattern);
            }
        }
    }

    // remove duplicates while preserving order
    std::vector<std::string> unique;
    std::set<std::string> seen;
    for (const auto& s : result) {
        std::string normalized = fs::path(s).lexically_normal().string();
        if (seen.find(normalized) == seen.end()) {
            seen.insert(normalized);
            unique.push_back(s);
        }
    }

    return unique;
}
std::vector<std::string> Engine::expand_glob(const std::string& pattern) const {
    std::vector<std::string> result;
    
    // handle ** recursive pattern
    bool recursive = pattern.find("**") != std::string::npos;
    
    // split pattern into directory and file pattern
    std::string dir_part;
    std::string file_pattern;
    
    size_t last_slash = pattern.rfind('/');
    if (last_slash != std::string::npos) {
        dir_part = pattern.substr(0, last_slash);
        file_pattern = pattern.substr(last_slash + 1);
    } else {
        dir_part = ".";
        file_pattern = pattern;
    }
    
    // remove ** from dir_part if present
    size_t double_star = dir_part.find("**");
    if (double_star != std::string::npos) {
        if (double_star == 0) {
            dir_part = ".";
        } else {
            dir_part = dir_part.substr(0, double_star - 1);
        }
        recursive = true;
    }
    
    // convert file pattern to regex
    std::string regex_str = "^";
    for (char c : file_pattern) {
        switch (c) {
            case '*': regex_str += ".*"; break;
            case '?': regex_str += "."; break;
            case '.': regex_str += "\\."; break;
            default: regex_str += c; break;
        }
    }
    regex_str += "$";
    
    std::regex re;
    try {
        re = std::regex(regex_str);
    } catch (...) {
        return result;
    }
    
    if (!fs::exists(dir_part)) {
        return result;
    }
    
    auto match_file = [&](const fs::directory_entry& entry) {
        if (!entry.is_regular_file()) return;
        std::string filename = entry.path().filename().string();
        if (std::regex_match(filename, re)) {
            result.push_back(entry.path().string());
        }
    };
    
    try {
        if (recursive) {
            for (const auto& entry : fs::recursive_directory_iterator(dir_part)) {
                match_file(entry);
            }
        } else {
            for (const auto& entry : fs::directory_iterator(dir_part)) {
                match_file(entry);
            }
        }
    } catch (...) {
        // ignore filesystem errors
    }
    
    std::sort(result.begin(), result.end());
    return result;
}
std::string Engine::get_compiler() const {
    if (!m_config.compiler.empty()) {
        return m_config.compiler;
    }

    // check environment
    const char* cc = std::getenv("CC");
    if (cc && cc[0] != '\0') {
        return cc;
    }

    // default based on language
    if (m_config.language == "c") {
        return "cc";
    }
    
    return "cc";
}

std::string Engine::get_cxx_compiler() const {
    // check environment
    const char* cxx = std::getenv("CXX");
    if (cxx && cxx[0] != '\0') {
        return cxx;
    }
    
    // derive from C compiler
    std::string cc = get_compiler();
    if (cc == "gcc" || cc == "cc") {
        return "g++";
    }
    if (cc == "clang") {
        return "clang++";
    }
    
    return "c++";
}

std::string Engine::get_compile_flags(const Target& target) const {
    std::stringstream flags;

    // language standard
    if (!m_config.standard.empty()) {
        flags << "-std=" << m_config.standard << " ";
    }

    // build type flags
    if (m_config.build_type == "debug") {
        flags << "-g -O0 ";
    } else if (m_config.build_type == "release") {
        flags << "-O3 -DNDEBUG ";
    } else if (m_config.build_type == "relwithdebinfo") {
        flags << "-O2 -g -DNDEBUG ";
    } else if (m_config.build_type == "minsize") {
        flags << "-Os -DNDEBUG ";
    }

    // global flags
    for (const auto& f : m_config.global_flags) {
        flags << f << " ";
    }

    // Ttarget flags
    for (const auto& f : target.flags) {
        flags << f << " ";
    }

    // global includes
    for (const auto& inc : m_config.global_includes) {
        flags << "-I../" << inc << " ";
    }

    // target includes
    for (const auto& inc : target.includes) {
        flags << "-I../" << inc << " ";
    }

    // global defines
    for (const auto& [key, val] : m_config.global_defines) {
        flags << "-D" << key;
        if (!val.empty()) {
            flags << "=" << val;
        }
        flags << " ";
    }

    // target defines
    for (const auto& [key, val] : target.defines) {
        flags << "-D" << key;
        if (!val.empty()) {
            flags << "=" << val;
        }
        flags << " ";
    }

    // position independent code for shared libraries
    if (target.type == TargetType::SharedLibrary) {
        flags << "-fPIC ";
    }

    return flags.str();
}

std::string Engine::get_link_flags(const Target& target) const {
    std::stringstream flags;

    // build type
    if (m_config.build_type == "release" || m_config.build_type == "minsize") {
        flags << "-s ";  // Strip symbols
    }

    // target link flags
    for (const auto& f : target.link_flags) {
        flags << f << " ";
    }

    return flags.str();
}

std::string Engine::get_libs(const Target& target) const {
    std::stringstream libs;

    // link against dependencies
    for (const auto& dep_name : target.dependencies) {
        // check if its an internal target
        bool is_internal = false;
        for (const auto& t : m_config.targets) {
            if (t.name == dep_name) {
                is_internal = true;
                if (t.type == TargetType::Library || t.type == TargetType::StaticLibrary) {
                    libs << "lib" << dep_name << ".a ";
                } else if (t.type == TargetType::SharedLibrary) {
                    libs << "-L. -l" << dep_name << " ";
                }
                break;
            }
        }
        
        if (!is_internal) {
            // assume its an external library
            libs << "-l" << dep_name << " ";
        }
    }

    return libs.str();
}

// dependency tracking

std::vector<std::string> Engine::get_build_order() const {
    Graph graph(m_config);
    
    if (graph.has_cycle()) {
        throw std::runtime_error("Circular dependency detected");
    }
    
    return graph.topological_sort();
}

bool Engine::needs_rebuild(const std::string& target_name) const {
    // find the target
    const Target* target = nullptr;
    for (const auto& t : m_config.targets) {
        if (t.name == target_name) {
            target = &t;
            break;
        }
    }
    
    if (!target) {
        return true;
    }
    
    // determine output path
    std::string output;
    switch (target->type) {
        case TargetType::Executable:
            output = m_build_dir + "/" + target->name;
            break;
        case TargetType::Library:
        case TargetType::StaticLibrary:
            output = m_build_dir + "/lib" + target->name + ".a";
            break;
        case TargetType::SharedLibrary:
            output = m_build_dir + "/lib" + target->name + ".so";
            break;
        default:
            return true;
    }
    
    if (!fs::exists(output)) {
        return true;
    }
    
    // check if any source is newer than output
    auto output_time = fs::last_write_time(output);
    
    auto sources = resolve_sources(*target);
    for (const auto& src : sources) {
        if (fs::exists(src)) {
            if (fs::last_write_time(src) > output_time) {
                return true;
            }
        }
    }
    
    return false;
}

} // namespace iris::core
